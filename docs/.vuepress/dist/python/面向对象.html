<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面向对象编程 | 上学时笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/school-note/images/myfavicon.png">
    <meta name="description" content="怀念象牙塔时光">
    
    <link rel="preload" href="/school-note/assets/css/0.styles.c30ed50d.css" as="style"><link rel="preload" href="/school-note/assets/js/app.73bf7409.js" as="script"><link rel="preload" href="/school-note/assets/js/2.26c8f057.js" as="script"><link rel="preload" href="/school-note/assets/js/1.9edbc7d9.js" as="script"><link rel="preload" href="/school-note/assets/js/17.0008473c.js" as="script"><link rel="prefetch" href="/school-note/assets/js/10.6bf41d69.js"><link rel="prefetch" href="/school-note/assets/js/11.e082b28d.js"><link rel="prefetch" href="/school-note/assets/js/12.424063fd.js"><link rel="prefetch" href="/school-note/assets/js/13.0267b344.js"><link rel="prefetch" href="/school-note/assets/js/14.0bb9e20e.js"><link rel="prefetch" href="/school-note/assets/js/15.ab6d52d4.js"><link rel="prefetch" href="/school-note/assets/js/16.de32fbbc.js"><link rel="prefetch" href="/school-note/assets/js/18.b6751064.js"><link rel="prefetch" href="/school-note/assets/js/19.6e0b99d6.js"><link rel="prefetch" href="/school-note/assets/js/20.3b4e6714.js"><link rel="prefetch" href="/school-note/assets/js/21.1744c71c.js"><link rel="prefetch" href="/school-note/assets/js/22.9aa39c11.js"><link rel="prefetch" href="/school-note/assets/js/23.8cc53d28.js"><link rel="prefetch" href="/school-note/assets/js/24.77c390b0.js"><link rel="prefetch" href="/school-note/assets/js/25.f6de6ff0.js"><link rel="prefetch" href="/school-note/assets/js/26.d1e01b93.js"><link rel="prefetch" href="/school-note/assets/js/27.903242ff.js"><link rel="prefetch" href="/school-note/assets/js/28.c2317508.js"><link rel="prefetch" href="/school-note/assets/js/29.6cbedfef.js"><link rel="prefetch" href="/school-note/assets/js/3.fd9cce16.js"><link rel="prefetch" href="/school-note/assets/js/30.af6d03e5.js"><link rel="prefetch" href="/school-note/assets/js/31.bb5e7344.js"><link rel="prefetch" href="/school-note/assets/js/32.51b20337.js"><link rel="prefetch" href="/school-note/assets/js/33.083fc63c.js"><link rel="prefetch" href="/school-note/assets/js/34.dad7dccc.js"><link rel="prefetch" href="/school-note/assets/js/35.2abc5866.js"><link rel="prefetch" href="/school-note/assets/js/36.7378acee.js"><link rel="prefetch" href="/school-note/assets/js/37.a87ee0a1.js"><link rel="prefetch" href="/school-note/assets/js/38.65687f94.js"><link rel="prefetch" href="/school-note/assets/js/39.209bbb9b.js"><link rel="prefetch" href="/school-note/assets/js/4.0aa80050.js"><link rel="prefetch" href="/school-note/assets/js/40.90f54a73.js"><link rel="prefetch" href="/school-note/assets/js/41.a0e6d671.js"><link rel="prefetch" href="/school-note/assets/js/42.c2055b49.js"><link rel="prefetch" href="/school-note/assets/js/43.a735dafb.js"><link rel="prefetch" href="/school-note/assets/js/44.7632fb56.js"><link rel="prefetch" href="/school-note/assets/js/45.ff9516d6.js"><link rel="prefetch" href="/school-note/assets/js/46.c8cf5cd5.js"><link rel="prefetch" href="/school-note/assets/js/47.a1229e08.js"><link rel="prefetch" href="/school-note/assets/js/48.91f60079.js"><link rel="prefetch" href="/school-note/assets/js/49.70afd433.js"><link rel="prefetch" href="/school-note/assets/js/5.d1a412fe.js"><link rel="prefetch" href="/school-note/assets/js/6.bb714e54.js"><link rel="prefetch" href="/school-note/assets/js/7.10f49e1d.js"><link rel="prefetch" href="/school-note/assets/js/vendors~docsearch.06a8db8f.js">
    <link rel="stylesheet" href="/school-note/assets/css/0.styles.c30ed50d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/school-note/" class="home-link router-link-active"><!----> <span class="site-name">上学时笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>matlab</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>python</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/school-note/python/pycharm出现的问题及解决方法.html" class="sidebar-link">pycharm项目中出现的问题及解决方法</a></li><li><a href="/school-note/python/python函数.html" class="sidebar-link">python函数</a></li><li><a href="/school-note/python/python语法规则.html" class="sidebar-link">python语法规则</a></li><li><a href="/school-note/python/面向对象.html" class="active sidebar-link">面向对象编程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>无人机项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数字图像处理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深度学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>信源数估计</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="面向对象-oop-基本概念"><a href="#面向对象-oop-基本概念" class="header-anchor">#</a> 面向对象(OOP)基本概念</h2> <p>面向对象编程 —— <code>Object Oriented Programming</code> 简写 <code>OOP</code>。<br> <strong>面向过程</strong> 和 <strong>面向对象</strong>，是两种不同的 <strong>编程方式</strong>。</p> <h3 id="过程和对象"><a href="#过程和对象" class="header-anchor">#</a> 过程和对象</h3> <ul><li><strong>过程</strong> 是早期的一个编程概念。</li> <li><strong>过程</strong> 类似于函数，只能执行，但是没有返回值。</li> <li><strong>函数</strong> 不仅能执行，还可以返回结果。</li></ul> <h3 id="面向过程"><a href="#面向过程" class="header-anchor">#</a> 面向过程</h3> <ol><li><strong>面向过程 —— 怎么做？</strong></li></ol> <ul><li>把完成某一个需求的所有步骤从头到尾逐步实现。</li> <li>根据开发需求，将某些功能独立的代码封装成一个又一个函数。</li> <li>最后完成的代码，就是顺序地调用不同的函数。</li></ul> <ol start="2"><li><strong>特点</strong></li></ol> <ul><li>注重步骤与过程，不注重职责分工。</li> <li>如果需求复杂，代码会变得很复杂。
<ul><li>开发复杂项目，没有固定的套路，开发难度很大！</li></ul></li></ul> <div align="center"><img src="/school-note/assets/img/001_面向过程示意图.c0d6bf54.png" width="80%"></div> <h3 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h3> <p>相比较函数，<strong>面向对象</strong> 是 <strong>更大</strong> 的 <strong>封装</strong> ，根据 <strong>职责</strong> 在 <strong>一个对象中</strong> 封装 <strong>多个方法</strong> 。</p> <ol><li><strong>面向对象 —— 谁来做</strong></li></ol> <ul><li>在完成某一个需求前，首先确定职责 —— 要做的事情（方法）。</li> <li>根据职责确定不同的对象，在对象内部封装不同的方法（多个）。</li> <li>最后完成的代码，就是顺序地让不同的对象 调用不同的方法。</li></ul> <ol start="2"><li><strong>特点</strong></li></ol> <ul><li>注重对象和职责，不同的对象承担不同的职责。</li> <li>更加适合应对复杂的需求变化，是专门应对复杂项目开发提供的固定套路。</li> <li>需要在面向过程基础上，再学习一些面向对象的语法。</li></ul> <h2 id="类和对象"><a href="#类和对象" class="header-anchor">#</a> 类和对象</h2> <p><strong>类</strong> 和 <strong>对象</strong> 是 <strong>面向对象编程的</strong> 两个 <strong>核心概念</strong> 。</p> <h3 id="类"><a href="#类" class="header-anchor">#</a> 类</h3> <ul><li><strong>类</strong> 是对一群具有 <strong>相同</strong> <strong>特征</strong> 或者 <strong>行为</strong> 的事物的一个统称，是抽象的，不能直接使用。
<ul><li><strong>特征</strong> 被称为 <strong>属性</strong> 。</li> <li><strong>行为</strong> 被称为 <strong>方法</strong> 。</li></ul></li> <li><strong>类</strong> 就相当于制造飞机时的图纸，是一个 <strong>模板</strong>，是 <strong>负责创建对象的</strong>。</li></ul> <h3 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h3> <ul><li><strong>对象</strong> 是 <strong>由类创建出来的一个具体存在</strong>，可以直接使用。</li> <li>由 <strong>哪一个类</strong> 创建出来的 <strong>对象</strong>，就拥有在 <strong>哪一个类</strong> 中定义的 <strong>属性</strong> 和 <strong>方法</strong> 。</li> <li><strong>对象</strong> 就相当于用 <strong>图纸</strong> <strong>制造</strong> 的飞机。</li> <li>在程序开发中，应该 <strong>先有类，再有对象</strong> 。</li></ul> <h3 id="类和对象的关系"><a href="#类和对象的关系" class="header-anchor">#</a> 类和对象的关系</h3> <ul><li><strong>类是模板，对象</strong> 是根据 <strong>类</strong> 这个模板创建出来的，应该 <strong>先有类，再有对象</strong> 。</li> <li><strong>类</strong> 只有一个，而 <strong>对象</strong> 可以有很多个。</li> <li><strong>不同的对象</strong> 之间 <strong>属性</strong> 可能会各不相同。</li> <li><strong>类</strong> 中定义了什么 <strong>属性和方法</strong> ，<strong>对象</strong> 中就有什么属性和方法，不可能多，也不可能少。</li></ul> <h3 id="类的设计"><a href="#类的设计" class="header-anchor">#</a> 类的设计</h3> <p>在使用面向对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！
</p><div align="left"><img src="/school-note/assets/img/002_类的设计示例.3e342f56.png" width="90%"></div><p></p> <ol><li><p>在程序开发中，要设计一个类，通常需要满足一下三个要素：</p> <ul><li><strong>类名</strong> 这类事物的名字，满足 <strong>大驼峰命名法</strong>。
<ul><li>每一个单词的首字母大写。</li> <li>单词与单词之间没有下划线。</li></ul></li> <li><strong>属性</strong> 这类事物具有什么样的特征。</li> <li><strong>方法</strong> 这类事物具有什么样的行为。</li></ul></li> <li><p>属性和方法的确定</p> <ul><li>对 <strong>对象的特征描述</strong>，通常可以定义成 <strong>属性</strong> 。</li> <li><strong>对象具有的行为</strong>（动词），通常可以定义成 <strong>方法</strong> 。</li></ul></li></ol> <h2 id="面向对象基础语法"><a href="#面向对象基础语法" class="header-anchor">#</a> 面向对象基础语法</h2> <h3 id="dir内置函数"><a href="#dir内置函数" class="header-anchor">#</a> dir内置函数</h3> <p>在 <code>Python</code> 中 对象几乎是无所不在的，我们之前学习的 <strong>变量、数据、函数</strong> 都是对象，在 <code>Python</code> 中可以使用以下两个方法验证：</p> <ul><li>在 <strong>标识符</strong> / <strong>数据</strong> 后输入一个 <code>.</code>，然后按下 <code>TAB</code> 键，<code>iPython</code> 会提示该对象能够调用的 <strong>方法列表</strong></li> <li>使用内置函数 <code>dir</code> 传入 <strong>标识符</strong> / <strong>数据</strong>，可以查看对象内的 <strong>所有属性及方法</strong></li></ul> <p>提示 <code>__方法名__</code>格式的方法是<code>Python</code> 提供的 <strong>内置方法</strong> / <strong>属性</strong></p> <table><thead><tr><th>序号</th> <th>方法名</th> <th>类型</th> <th>作用</th></tr></thead> <tbody><tr><td>01</td> <td><strong>__new__</strong></td> <td>方法</td> <td>创建对象时，会被 <strong>自动</strong> 调用</td></tr> <tr><td>02</td> <td><strong>__init__</strong></td> <td>方法</td> <td>对象被初始化时，会被 <strong>自动</strong> 调用</td></tr> <tr><td>03</td> <td><strong>__del__</strong></td> <td>方法</td> <td>对象被从内存中销毁前，会被 <strong>自动</strong> 调用</td></tr> <tr><td>04</td> <td><strong>__str__</strong></td> <td>方法</td> <td>返回对象的描述信息，print 函数输出使用</td></tr></tbody></table> <p><strong>提示</strong> 利用好 <code>dir()</code> 函数，在学习时很多内容就不需要死记硬背了</p> <h3 id="定义简单的类"><a href="#定义简单的类" class="header-anchor">#</a> 定义简单的类</h3> <p><strong>面向对象</strong> 是 <strong>更大</strong> 的 <strong>封装</strong>，在 <strong>一个类中</strong> <strong>封装</strong> <strong>多个方法</strong>，这样 <strong>通过这个类创建出来的对象，就可以直接调用这些方法了</strong>！</p> <h4 id="定义只包含方法的类"><a href="#定义只包含方法的类" class="header-anchor">#</a> 定义只包含方法的类</h4> <ul><li>在 <strong>Python</strong> 中要定义一个只包含方法的类，语法格式如下：</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> 类名<span class="token punctuation">:</span>
    <span class="token keyword">def</span> 方法<span class="token number">1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> 参数列表<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span> 
    <span class="token keyword">def</span> 方法<span class="token number">2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> 参数列表<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
</code></pre></div><p><strong>方法</strong> 的定义格式和之前学习过的 <strong>函数</strong> 几乎一样，区别在于第一个参数必须是 <strong>self</strong><br> <strong>注意</strong> ：<strong>类名</strong> 的 <strong>命名规则</strong> 要符合 <strong>大驼峰命名法</strong></p> <h4 id="创建对象"><a href="#创建对象" class="header-anchor">#</a> 创建对象</h4> <ul><li>当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：</li></ul> <div class="language-python extra-class"><pre class="language-python"><code>对象变量 <span class="token operator">=</span> 类名<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h4> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 小猫爱吃鱼，小猫要喝水</span>

<span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;小猫爱吃鱼&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">drink</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;小猫在喝水&quot;</span><span class="token punctuation">)</span>

tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>
tom<span class="token punctuation">.</span>drink<span class="token punctuation">(</span><span class="token punctuation">)</span>
tom<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="引用概念的强调"><a href="#引用概念的强调" class="header-anchor">#</a> 引用概念的强调</h4> <p>在<strong>面向对象</strong>开发中，<strong>引用</strong>的概念是<strong>同样适用</strong>的！</p> <ul><li>在 <code>Python</code> 中使用类 <strong>创建对象之后</strong>，<code>tom</code> 变量中仍然记录的是 <strong>对象在内存中的地址</strong>，也就是 <code>tom</code> 变量 <strong>引用了新建的猫对象</strong></li> <li>使用 <code>print</code> 输出 <strong>对象变量</strong>，默认情况下，是能够输出这个变量 <strong>引用的对象</strong> 是 <strong>由哪一个类创建的对象</strong>，以及 <strong>在内存中的地址（十六进制表示）</strong></li></ul> <h3 id="方法中的self参数"><a href="#方法中的self参数" class="header-anchor">#</a> 方法中的self参数</h3> <h4 id="给对象增加属性"><a href="#给对象增加属性" class="header-anchor">#</a> 给对象增加属性</h4> <p>在 <code>Python</code> 中，要 <strong>给对象设置属性</strong>，非常的容易，只需要在 <strong>类的外部的代码</strong> 中直接通过 <code>.</code> 设置一个属性即可，<strong>但是不推荐使用</strong>，因为<strong>对象属性的封装</strong>应该封装在<strong>类的内部</strong></p> <div class="language-python extra-class"><pre class="language-python"><code>tom<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Tom&quot;</span>
lazy_cat<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;大懒猫&quot;</span>
</code></pre></div><h4 id="使用self在方法内部输出每一只猫的名字"><a href="#使用self在方法内部输出每一只猫的名字" class="header-anchor">#</a> 使用self在方法内部输出每一只猫的名字</h4> <p>由 <strong>哪一个对象</strong> 调用的方法，方法内的 <strong><code>self</code></strong> 就是 <strong>哪一个对象的引用</strong></p> <ul><li>在类封装的方法内部，<strong><code>self</code></strong> 就表示 <strong>当前调用方法的对象自己</strong></li> <li><strong>调用方法时</strong>，程序员不需要传递 <strong><code>self</code></strong> 参数</li> <li><strong>在方法内部</strong> <ul><li>可以通过 <strong><code>self.</code></strong> 访问对象的属性</li> <li>也可以通过 <strong><code>self.</code></strong> 调用对象的方法</li></ul></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 爱吃鱼&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>
tom<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Tom&quot;</span>
tom<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>在 <strong>类的外部</strong>，通过 <strong><code>变量名.</code></strong> 访问对象的 <strong>属性和方法</strong></li> <li>在 <strong>类封装的方法中</strong>，通过 <strong><code>self.</code></strong> 访问对象的 <strong>属性和方法</strong></li></ul> <h3 id="初始化方法"><a href="#初始化方法" class="header-anchor">#</a> 初始化方法</h3> <h4 id="初始化方法-2"><a href="#初始化方法-2" class="header-anchor">#</a> 初始化方法</h4> <ul><li>当使用 <strong><code>类名()</code></strong> 创建对象时，会 <strong>自动</strong> 执行以下操作：
<ol><li>为对象在内存中 <strong>分配空间</strong> —— 创建对象</li> <li>为对象的属性 <strong>设置初始值</strong> —— 初始化方法(<code>__init__</code>)</li></ol></li> <li>初始化方法 就是 <strong><code>__init__</code></strong> 方法，<strong><code>__init__</code></strong> 是对象的内置方法，专门用来定义一个类具有哪些属性的方法！</li></ul> <h4 id="在初始化方法内部定义属性"><a href="#在初始化方法内部定义属性" class="header-anchor">#</a> 在初始化方法内部定义属性</h4> <ul><li>在 <strong><code>__init__</code></strong> 方法内部使用 <strong><code>self.属性名 = 属性的初始值</code></strong> 就可以 <strong>定义属性</strong></li> <li>定义属性之后，再使用类创建的对象，都会拥有该属性</li> <li>在定义属性时，如果 <strong>不知道设置什么初始值</strong>，可以设置为 <code>None</code> <ul><li><code>None</code> <strong>关键字</strong> 表示 <strong>什么都没有</strong></li> <li>表示一个 <strong>空对象，没有方法和属性，是一个特殊的常量</strong></li> <li>可以将 <code>None</code> 赋值给任何一个变量</li></ul></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;这是一个初始化方法&quot;</span><span class="token punctuation">)</span>       
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Tom&quot;</span>

    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 爱吃鱼&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment"># 使用类名()创建对象的时候，会自动调用初始化方法 __init__</span>
tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>
tom<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="初始化的同时设置初始值"><a href="#初始化的同时设置初始值" class="header-anchor">#</a> 初始化的同时设置初始值</h4> <ul><li>在开发中，如果希望在 <strong>创建对象的同时，就设置对象的属性</strong>，可以对 <code>__init__</code> 方法进行改造
<ol><li>把希望设置的属性值，定义成 <code>__init__</code> 方法的参数</li> <li>在方法内部使用 <code>self.属性 = 形参</code> 接收外部传递的参数</li> <li>在创建对象时，使用 <code>类名(属性1, 属性2...)</code> 调用</li></ol></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;初始化方法 %s&quot;</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    
tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">)</span>
lazy_cat <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">&quot;大懒猫&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="内置方法和属性"><a href="#内置方法和属性" class="header-anchor">#</a> 内置方法和属性</h3> <h4 id="del-方法"><a href="#del-方法" class="header-anchor">#</a> __del__方法</h4> <ul><li><p>在 <code>Python</code> 中</p> <ul><li>当使用 <code>类名()</code> 创建对象时，为对象 <strong>分配完空间后</strong>，<strong>自动</strong> 调用 <code>__init__</code> 方法</li> <li>当一个 <strong>对象被从内存中销毁</strong> 前，会 <strong>自动</strong> 调用 <code>__del__</code> 方法</li></ul></li> <li><p><strong>应用场景</strong></p> <ul><li><code>__init__</code> 改造初始化方法，可以让创建对象更加灵活</li> <li><code>__del__</code> 如果希望在对象被销毁前，再做一些事情，可以考虑一下 <code>__del__</code> 方法</li></ul></li> <li><p><strong>生命周期</strong></p> <ul><li>一个对象从调用 <code>类名()</code> 创建，生命周期开始</li> <li>一个对象的 <code>__del__</code> 方法一旦被调用，生命周期结束</li> <li>在对象的生命周期内，可以访问对象属性，或者让对象调用方法</li></ul></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> new_name
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 来了&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 去了&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment"># tom 是一个全局变量</span>
tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>tom<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment"># del 关键字可以删除一个对象</span>
<span class="token keyword">del</span> tom
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="str-方法"><a href="#str-方法" class="header-anchor">#</a> __str__方法</h4> <ul><li>在 <code>Python</code> 中，使用 <code>print</code> 输出 <strong>对象变量</strong>，默认情况下，会输出这个变量 <strong>引用的对象</strong> 是 <strong>由哪一个类创建的对象</strong>，以及 <strong>在内存中的地址（十六进制表示）</strong></li> <li>如果在开发中，希望使用 <code>print</code> 输出 <strong>对象变量</strong> 时，能够打印 <strong>自定义的内容</strong>，就可以利用 <code>__str__</code> 这个内置方法了</li></ul> <p><strong>注意</strong>：<code>__str__</code> 方法必须返回一个字符串</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> new_name
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 来了&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 去了&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">&quot;我是小猫：%s&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name

tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>tom<span class="token punctuation">)</span>
</code></pre></div><h3 id="身份运算符"><a href="#身份运算符" class="header-anchor">#</a> 身份运算符</h3> <p>身份运算符用于 <strong>比较</strong> 两个对象的 <strong>内存地址</strong> 是否一致 —— <strong>是否是对同一个对象的引用</strong></p> <ul><li>在 <code>Python</code> 中针对 <code>None</code> 比较时，建议使用 <code>is</code> 判断</li></ul> <table><thead><tr><th>运算符</th> <th>描述</th> <th>实例</th></tr></thead> <tbody><tr><td>is</td> <td>is 是判断两个标识符是不是引用同一个对象</td> <td><code>x is y</code>，类似 <code>id(x) == id(y)</code></td></tr> <tr><td>is not</td> <td>is not 是判断两个标识符是不是引用不同对象</td> <td><code>x is not y</code>，类似 <code>id(a) != id(b)</code></td></tr></tbody></table> <ul><li><code>is</code> 与 <code>==</code> 区别：
<ul><li><code>is</code> 用于判断 <strong>两个变量</strong> <strong>引用对象是否为同一个</strong></li> <li><code>==</code> 用于判断 <strong>引用变量的值</strong> <strong>是否相等</strong></li></ul></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token keyword">is</span> a 
<span class="token boolean">False</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">==</span> a
<span class="token boolean">True</span>
</code></pre></div><h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="header-anchor">#</a> 私有属性和私有方法</h2> <h3 id="应用场景及定义方式"><a href="#应用场景及定义方式" class="header-anchor">#</a> 应用场景及定义方式</h3> <p><strong>应用场景</strong></p> <ul><li>在实际开发中，<strong>对象</strong> 的 <strong>某些属性或方法</strong> 可能只希望 <strong>在对象的内部被使用</strong>，而 <strong>不希望在外部被访问到</strong></li> <li><strong>私有属性</strong> 就是 <strong>对象不希望公开的属性</strong></li> <li><strong>私有方法</strong> 就是 <strong>对象不希望公开的方法</strong></li></ul> <p><strong>定义方式</strong></p> <ul><li>在 <strong>定义属性或方法</strong>时，在 <strong>属性名或者方法名前</strong> 增加 <strong>两个下划线</strong>，定义的就是 <strong>私有属性或方法</strong></li></ul> <div align="left"><img src="/school-note/assets/img/003_私有属性和方法.132e29da.png" width="30%"></div> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Women</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token comment"># 不要问女生的年龄</span>
        self<span class="token punctuation">.</span>__age <span class="token operator">=</span> <span class="token number">18</span>

    <span class="token keyword">def</span> <span class="token function">__secret</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;我的年龄是 %d&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>__age<span class="token punctuation">)</span>

xiaofang <span class="token operator">=</span> Women<span class="token punctuation">(</span><span class="token string">&quot;小芳&quot;</span><span class="token punctuation">)</span>
<span class="token comment"># 私有属性，外部不能直接访问</span>
<span class="token comment"># print(xiaofang.__age)</span>

<span class="token comment"># 私有方法，外部不能直接调用</span>
<span class="token comment"># xiaofang.__secret()</span>
</code></pre></div><h3 id="伪私有属性和伪私有方法"><a href="#伪私有属性和伪私有方法" class="header-anchor">#</a> 伪私有属性和伪私有方法</h3> <p><code>Python</code> 中，并没有 <strong>真正意义</strong> 的 <strong>私有</strong></p> <ul><li>在给 <strong>属性、方法</strong> 命名时，实际是对 <strong>名称</strong> 做了一些特殊处理，使得外界无法访问到</li> <li>在 <strong>名称</strong> 前面加上 <code>_类名</code> 使变成<code>_类名__名称</code>便可以间接访问</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 私有属性，外部不能直接访问到</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>xiaofang<span class="token punctuation">.</span>_Women__age<span class="token punctuation">)</span>

<span class="token comment"># 私有方法，外部不能直接调用</span>
xiaofang<span class="token punctuation">.</span>_Women__secret<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>注意</strong>：在日常开发中，不要使用这种方式访问对象的 <strong>私有属性</strong> 或 <strong>私有方法</strong></p> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p><strong>面向对象三大特性</strong></p> <ul><li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li> <li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li> <li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li></ul> <h3 id="单继承"><a href="#单继承" class="header-anchor">#</a> 单继承</h3> <h4 id="继承的概念、语法和特点"><a href="#继承的概念、语法和特点" class="header-anchor">#</a> 继承的概念、语法和特点</h4> <p><strong>继承的概念</strong>：<strong>子类</strong> 拥有 <strong>父类</strong> 的 <strong>所有方法和属性</strong></p> <div align="center"><img src="/school-note/assets/img/004_继承对比图示.8ff98db2.png" width="90%"></div> <ol><li>继承的语法</li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> 类名<span class="token punctuation">(</span>父类名<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre></div><ul><li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接享受父类中已经封装好的方法，不需要再次开发</li> <li><strong>子类</strong> 中应该根据 <strong>职责</strong>，封装 <strong>子类特有的</strong> <strong>属性和方法</strong></li></ul> <ol start="2"><li>专业术语</li></ol> <ul><li><code>Dog</code> 类是 <code>Animal</code> 类的子类，<code>Animal</code> 类是 <code>Dog</code> 类的父类，<code>Dog</code> 类从 <code>Animal</code> 类继承</li> <li><code>Dog</code> 类是 <code>Animal</code> 类的派生类，<code>Animal</code> 类是 <code>Dog</code> 类的基类，<code>Dog</code> 类从 <code>Animal</code> 类派生</li></ul> <ol start="3"><li>继承的传递性</li></ol> <ul><li><code>C</code> 类从 <code>B</code> 类继承，<code>B</code> 类又从 <code>A</code> 类继承</li> <li>那么 <code>C</code> 类就具有 <code>B</code> 类和 <code>A</code> 类的所有属性和方法</li></ul> <h4 id="方法的重写"><a href="#方法的重写" class="header-anchor">#</a> 方法的重写</h4> <p><strong>应用场景</strong></p> <ul><li>当 <strong>父类</strong> 的方法实现不能满足子类需求时，可以对方法进行 <strong>重写(override)</strong></li> <li><strong>重写</strong> 父类方法有两种情况：
<ul><li><strong>覆盖</strong> 父类的方法</li> <li>对父类方法进行 <strong>扩展</strong></li></ul></li></ul> <ol><li><p><strong>覆盖父类的方法</strong></p> <ul><li>如果在开发中，<strong>父类的方法实现</strong> 和 <strong>子类的方法实现</strong> 完全不同，就可以使用 <strong>覆盖</strong> 的方式，在子类中 <strong>重新编写</strong> 父类的方法实现</li> <li>具体的实现方式，就相当于在 <strong>子类中</strong> 定义了一个 <strong>和父类同名的方法并且实现</strong></li> <li>重写之后，在运行时，只会调用 <strong>子类中重写的方法</strong>，而不再会调用 <strong>父类封装的方法</strong></li></ul></li> <li><p><strong>对父类方法进行扩展</strong></p> <ul><li>如果在开发中，<strong>子类的方法实现</strong> 中 <strong>包含父类的方法实现</strong>，即 <strong>父类原本封装的方法</strong> 是 <strong>子类方法的一部分</strong>，就可以使用 <strong>扩展</strong> 的方式</li> <li>在子类中 <strong>重写</strong> 父类的方法：在需要的位置使用 <strong><code>super().父类方法</code></strong> 来调用父类方法的执行，代码其他的位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li></ul></li></ol> <h4 id="关于-super"><a href="#关于-super" class="header-anchor">#</a> <strong>关于 super</strong></h4> <ul><li><p>在 <code>Python</code> 中 <code>super</code> 是一个 <strong>特殊的类</strong>，<code>super()</code> 就是使用 <code>super</code> 类创建出来的对象。</p></li> <li><p><code>super</code> 最常使用的场景就是在 <strong>重写父类方法</strong>时，调用 <strong>在父类中封装的方法实现</strong>。</p></li> <li><p>调用父类方法的另外一种方式<br>
在 <code>Python 2.x</code> 时，如果需要调用父类的方法，还可以使用方式：<code>父类名.方法(self)</code><br>
目前在 <code>Python 3.x</code> 还支持这种方式，但不推荐使用，因为一旦 <strong>父类发生变化</strong>，方法调用位置的 <strong>类名</strong> 同样需要修改</p></li> <li><p><strong>提示</strong><br>
在开发时， <code>父类名</code> 和 <code>super()</code> 两种方式不要混用<br>
如果使用 <strong>当前子类名</strong> 调用方法，会形成递归调用，出现死循环</p></li></ul> <h4 id="父类的私有属性和私有方法"><a href="#父类的私有属性和私有方法" class="header-anchor">#</a> <strong>父类的私有属性和私有方法</strong></h4> <ul><li><strong>子类对象不能</strong> 在自己的方法内部，<strong>直接</strong> 访问 <strong>父类的私有属性或私有方法</strong></li> <li><strong>子类对象</strong> 可以通过 <strong>父类公有方法</strong> <strong>间接</strong> 访问到 <strong>私有属性或私有方法</strong></li></ul> <p><strong>示例</strong></p><div align="left"><img src="/school-note/assets/img/005_父类的私有属性和私有方法.634dbd56.png" width="25%"></div><p></p> <ul><li><code>B</code> 的对象不能直接访问 <code>__num2</code> 属性</li> <li><code>B</code> 的对象不能在 <code>demo</code> 方法内访问 <code>__num2</code> 属性</li> <li><code>B</code> 的对象可以在 <code>demo</code> 方法内，调用父类的 <code>test</code> 方法</li> <li>父类的 <code>test</code> 方法内部，能够访问 <code>__num2</code> 属性和 <code>__test</code> 方法</li></ul> <h3 id="多继承"><a href="#多继承" class="header-anchor">#</a> 多继承</h3> <h4 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h4> <ul><li><strong>子类</strong> 可以拥有 <strong>多个父类</strong>，并且具有 <strong>所有父类</strong> 的 <strong>属性</strong> 和 <strong>方法</strong></li></ul> <h4 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h4> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> 子类名<span class="token punctuation">(</span>父类名<span class="token number">1</span><span class="token punctuation">,</span> 父类名<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token keyword">pass</span>
</code></pre></div><h4 id="多继承的使用注意事项"><a href="#多继承的使用注意事项" class="header-anchor">#</a> 多继承的使用注意事项</h4> <ul><li>如果 <strong>父类之间</strong> 存在 <strong>同名的属性或者方法</strong>，应该 <strong>尽量避免</strong> 使用多继承</li></ul> <h4 id="python-中的-mro-方法搜索顺序-知道"><a href="#python-中的-mro-方法搜索顺序-知道" class="header-anchor">#</a> Python 中的 MRO —— 方法搜索顺序（知道）</h4> <ul><li><code>Python</code> 中针对 <strong>类</strong> 提供了一个 <strong>内置属性</strong> <code>__mro__</code> ，可以查看 <strong>方法搜索顺序</strong></li> <li><code>MRO</code> 是 <code>method resolution order</code>，主要用于 <strong>在多继承时判断方法、属性的调用路径</strong></li></ul> <div class="language-python extra-class"><pre class="language-python"><code>In<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.C'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.B'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'object'</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>在搜索方法时，是按照 <code>__mro__</code> 的输出结果 <strong>从左至右</strong> 的顺序查找的</li> <li>如果在当前类中找到方法，就直接执行，不再搜索</li> <li>如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索</li> <li>如果找到最后一个类，还没有找到方法，程序报错</li></ul> <h4 id="新式类和旧式-经典-类"><a href="#新式类和旧式-经典-类" class="header-anchor">#</a> 新式类和旧式（经典）类</h4> <p><code>object</code> 是 <code>Python</code> 为所有对象提供的 <strong>基类</strong>，提供有一些内置的属性和方法，可以使用 <code>dir</code> 函数查看</p> <ul><li>新式类：以 <code>object</code> 为基类的类，推荐使用</li> <li>经典类：不以 <code>object</code> 为基类的类，不推荐使用</li> <li>在 <code>Python 3.x</code> 中定义类时，如果没有指定父类，会 <strong>默认使用</strong> <code>object</code> 作为该类的 基类 —— <code>Python 3.x</code> 中定义的类都是 <strong>新式类</strong></li> <li>在 <code>Python 2.x</code> 中定义类时，如果没有指定父类，则不会以 <code>object</code> 作为<strong>基类</strong></li> <li><strong>新式类</strong> 和 <strong>经典类</strong> 在多继承时 <strong>会影响到方法的搜索顺序</strong></li></ul> <p>为了保证编写的代码能够同时在 <code>Python 2.x</code> 和 <code>Python 3.x</code> 运行，今后在定义类时，如果没有父类，建议统一继承自 <code>object</code></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> 类名<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre></div><h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <h3 id="概念-2"><a href="#概念-2" class="header-anchor">#</a> 概念</h3> <p>不同的 <strong>子类对象</strong> 调用相同的 <strong>父类方法</strong>，产生不同的执行结果</p> <ul><li><strong>多态</strong> 可以 <strong>增加代码的灵活度</strong></li> <li>以 <strong>继承</strong> 和 <strong>重写父类方法</strong> 为前提</li> <li>是调用方法的技巧，<strong>不会影响到类的内部设计</strong></li></ul> <h3 id="多态示例"><a href="#多态示例" class="header-anchor">#</a> 多态示例</h3> <h4 id="需求"><a href="#需求" class="header-anchor">#</a> 需求</h4> <ol><li>在 <code>Dog</code> 类中封装方法 <code>game</code> <ul><li>普通狗只是简单的玩耍</li></ul></li> <li>定义 <code>XiaoTianDog</code> 继承自 <code>Dog</code>，并且重写 <code>game</code> 方法
<ul><li>哮天犬需要在天上玩耍</li></ul></li> <li>定义 <code>Person</code> 类，并且封装一个 和狗玩 的方法
<ul><li>在方法内部，直接让狗对象调用 <code>game</code> 方法</li></ul></li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">def</span> <span class="token function">game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 蹦蹦跳跳的玩耍...&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">XiaoTianDog</span><span class="token punctuation">(</span>Dog<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 飞到天上去玩耍...&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">def</span> <span class="token function">game_with_dog</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;%s 和 %s 快乐的玩耍...&quot;</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment"># 让狗玩耍</span>
        dog<span class="token punctuation">.</span>game<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 1. 创建一个狗对象</span>
<span class="token comment"># wangcai = Dog(&quot;旺财&quot;)</span>
wangcai <span class="token operator">=</span> XiaoTianDog<span class="token punctuation">(</span><span class="token string">&quot;飞天旺财&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 2. 创建一个小明对象</span>
xiaoming <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 让小明调用和狗玩的方法</span>
xiaoming<span class="token punctuation">.</span>game_with_dog<span class="token punctuation">(</span>wangcai<span class="token punctuation">)</span>     
</code></pre></div><h4 id="示例小结"><a href="#示例小结" class="header-anchor">#</a> 示例小结</h4> <ul><li><code>Person</code> 类中只需要让狗对象调用 <code>game</code> 方法，而不关心具体是什么狗
<ul><li><code>game</code> 方法是在 <code>Dog</code> 父类中定义的</li></ul></li> <li>在程序执行时，传入不同的狗对象实参，就会产生不同的执行效果</li></ul> <h2 id="类属性和类方法"><a href="#类属性和类方法" class="header-anchor">#</a> 类属性和类方法</h2> <h3 id="类的结构"><a href="#类的结构" class="header-anchor">#</a> 类的结构</h3> <h4 id="术语-实例"><a href="#术语-实例" class="header-anchor">#</a> 术语——实例</h4> <ol><li>使用面向对象开发，第 1 步 是设计 <strong>类</strong></li> <li>使用 <strong>类名()</strong> 创建对象，<strong>创建对象</strong> 的动作有两步：<br>
(1) 在内存中为对象 <strong>分配空间</strong><br>
(2) 调用初始化方法 <code>__init__</code> 为 <strong>对象初始化</strong></li> <li>对象创建后，<strong>内存</strong> 中就有了一个对象的 <strong>实实在在</strong> 的存在 —— <strong>实例</strong></li></ol> <div align="left"><img src="/school-note/assets/img/006_类的结构示意图I.db10688a.png" width="50%"></div> <p>因此，通常也会把：</p> <ol><li>创建出来的 <strong>对象</strong> 叫做 <strong>类的实例</strong></li> <li><strong>创建对象的动作</strong> 叫做 <strong>实例化</strong></li> <li><strong>对象的属性</strong> 叫做 <strong>实例属性</strong></li> <li><strong>对象调用的方法</strong> 叫做 <strong>实例方法</strong></li></ol> <p>在程序执行时：</p> <ol><li>对象各自拥有自己的 <strong>实例属性</strong></li> <li>调用对象方法，可以通过 <code>self</code>.
<ul><li>访问自己的属性</li> <li>调用自己的方法</li></ul></li></ol> <p><strong>结论</strong></p> <ul><li><strong>每一个对象</strong> 都有自己 <strong>独立的内存空间</strong>，保存各自不同的属性</li> <li><strong>多个对象的方法，在内存中只有一份</strong>，在调用方法时，<strong>需要把对象的引用</strong> 传递到方法内部</li></ul> <h4 id="类是一个特殊的对象"><a href="#类是一个特殊的对象" class="header-anchor">#</a> 类是一个特殊的对象</h4> <p><strong>Python中一切皆对象</strong>：</p> <ul><li><code>class AAA</code>: 定义的类属于 <strong>类对象</strong></li> <li><code>obj1 = AAA()</code> 属于 <strong>实例对象</strong></li></ul> <ol><li>在程序运行时，类同样会被加载到内存</li> <li>在 Python 中，类是一个特殊的对象 —— <strong>类对象</strong></li> <li>在程序运行时，<strong>类对象</strong> 在内存中 <strong>只有一份</strong>，使用一个类可以创建出很多个对象实例</li> <li>除了封装实例的属性和方法外，<strong>类对象</strong> 还可以拥有自己的属性和方法
<ul><li><strong>类属性</strong></li> <li><strong>类方法</strong></li></ul></li> <li>通过 <code>类名.</code> 的方式可以 <strong>访问类的属性</strong> 或者 <strong>调用类的方法</strong></li></ol> <div align="left"><img src="/school-note/assets/img/007_类的结构示意图II.968e836d.png" width="60%"></div> <h3 id="类属性和实例属性"><a href="#类属性和实例属性" class="header-anchor">#</a> 类属性和实例属性</h3> <h4 id="概念和使用"><a href="#概念和使用" class="header-anchor">#</a> 概念和使用</h4> <ul><li><strong>类属性</strong> 就是给 <strong>类对象</strong> 中定义的 <strong>属性</strong></li> <li>通常用来记录 <strong>与这个类相关</strong> 的<strong>特征</strong></li> <li>类属性不会用于记录具体对象的特征</li></ul> <p><strong>示例</strong></p> <ul><li>定义一个工具类</li> <li>每件工具都有自己的 <code>name</code></li> <li><strong>需求</strong> —— 知道使用这个类创建了多少个工具对象？</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Tool</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用赋值语句，定义类属性，记录创建工具对象的总数</span>
    count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token comment"># 针对类属性做一个计数+1</span>
        Tool<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token comment"># 创建工具对象</span>
tool1 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">&quot;斧头&quot;</span><span class="token punctuation">)</span>
tool2 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">&quot;榔头&quot;</span><span class="token punctuation">)</span>
tool3 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">&quot;铁锹&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;现在创建了 %d 个工具&quot;</span> <span class="token operator">%</span> Tool<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
</code></pre></div><h4 id="属性的获取机制"><a href="#属性的获取机制" class="header-anchor">#</a> 属性的获取机制</h4> <p>在 <code>Python</code> 中 <strong>属性的获取</strong> 存在一个 <strong>向上查找机制</strong></p> <div align="left"><img src="/school-note/assets/img/008_通过对象访问类属性.0124c39a.png" width="80%"></div> <ul><li>因此，要访问类属性有两种方式：
<ol><li><strong>类名.类属性</strong></li> <li><strong>对象.类属性</strong> （不推荐）</li></ol></li></ul> <p><strong>注意</strong></p> <ul><li>如果使用 <code>对象.类属性 = 值</code> 赋值语句，只会 <strong>给对象添加一个属性</strong>，而 <strong>不会影响到类属性的值</strong></li></ul> <h3 id="类方法和静态方法"><a href="#类方法和静态方法" class="header-anchor">#</a> 类方法和静态方法</h3> <h4 id="类方法"><a href="#类方法" class="header-anchor">#</a> 类方法</h4> <ul><li><strong>类属性</strong> 就是针对 <strong>类对象</strong> 定义的属性
<ul><li>使用 <strong>赋值语句</strong> 在 <code>class</code> 关键字下方可以定义 <strong>类属性</strong></li> <li><strong>类属性</strong> 用于记录 <strong>与这个类相关</strong> 的特征</li></ul></li> <li><strong>类方法</strong> 就是针对 <strong>类对象</strong> 定义的方法
<ul><li>在 <strong>类方法</strong> 内部可以 <strong>直接访问类属性</strong> 或者 <strong>调用其他的类方法</strong></li></ul></li></ul> <p><strong>语法如下</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@classmethod</span>
<span class="token keyword">def</span> 类方法名<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre></div><ul><li>类方法需要用 <strong>修饰器</strong> <code>@classmethod</code> 来标识，告诉解释器这是一个类方法</li> <li>类方法的 <strong>第一个参数</strong> 应该是 <code>cls</code> <ul><li>由 <strong>哪一个类</strong> 调用的方法，方法内的 <code>cls</code> 就是 <strong>哪一个类的引用</strong></li> <li>这个参数和 <strong>实例方法</strong> 的第一个参数是 <code>self</code> 类似</li> <li><strong>提示</strong>  使用其他名称也可以，不过习惯使用 <code>cls</code></li></ul></li> <li>通过 <strong><code>类名.</code></strong> 调用 <strong>类方法</strong>，调用方法时，不需要传递 <code>cls</code> 参数</li> <li><strong>在方法内部</strong> <ul><li>可以通过 <code>cls.</code> 访问类的属性</li> <li>也可以通过 <code>cls.</code> 调用其他的类方法</li></ul></li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@classmethod</span>
<span class="token keyword">def</span> <span class="token function">show_tool_count</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;显示工具对象的总数&quot;&quot;&quot;</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;工具对象的总数 %d&quot;</span> <span class="token operator">%</span> cls<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
</code></pre></div><h4 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h4> <p>在开发时，如果需要在<strong>类</strong>中封装一个方法，这个方法既<strong>不需要访问实例属性或者调用实例方法，也不需要访问类属性或者调用类方法</strong>，这个时候，可以把这个方法封装成一个<strong>静态方法</strong>。</p> <p><strong>语法如下</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@staticmethod</span>
<span class="token keyword">def</span> 静态方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre></div><ul><li><strong>静态方法</strong> 需要用 <strong>修饰器</strong> <code>@staticmethod</code> 来标识，告诉解释器这是一个静态方法</li> <li>通过 <strong><code>类名.</code></strong> 调用 <strong>静态方法</strong></li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
    <span class="token comment"># 狗对象计数</span>
    dog_count <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    
        <span class="token comment"># 不需要访问实例属性也不需要访问类属性的方法</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;狗在跑...&quot;</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name      
</code></pre></div><h4 id="综合示例"><a href="#综合示例" class="header-anchor">#</a> 综合示例</h4> <p><strong>需求</strong></p> <ol><li>设计一个 <code>Game</code> 类</li> <li>属性：
<ul><li>定义一个<strong>类属性</strong> <code>top_score</code> 记录游戏的历史最高分</li> <li>定义一个<strong>实例属性</strong> <code>player_name</code> 记录当前游戏的玩家姓名</li></ul></li> <li>方法：
<ul><li><strong>静态方法</strong> <code>show_help</code> 显示游戏帮助信息</li> <li><strong>类方法</strong> <code>show_top_score</code> 显示历史最高分</li> <li><strong>实例方法</strong> <code>start_game</code> 开始当前玩家的游戏</li></ul></li> <li>主程序步骤<br>
(1) 查看帮助信息<br>
(2) 查看历史最高分<br>
(3) 创建游戏对象，开始游戏</li></ol> <div align="left"><img src="/school-note/assets/img/009_方法综合案例.b286f6e0.png" width="40%"></div> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Game</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 游戏最高分，类属性</span>
    top_score <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">show_help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;帮助信息：让僵尸走进房间&quot;</span><span class="token punctuation">)</span>
        
    <span class="token decorator annotation punctuation">@classmethod</span>
    <span class="token keyword">def</span> <span class="token function">show_top_score</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;游戏最高分是 %d&quot;</span> <span class="token operator">%</span> cls<span class="token punctuation">.</span>top_score<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> player_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>player_name <span class="token operator">=</span> player_name

    <span class="token keyword">def</span> <span class="token function">start_game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;[%s] 开始游戏...&quot;</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>player_name<span class="token punctuation">)</span>
        
        <span class="token comment"># 使用类名.修改历史最高分</span>
        Game<span class="token punctuation">.</span>top_score <span class="token operator">=</span> <span class="token number">999</span>

<span class="token comment"># 1. 查看游戏帮助</span>
Game<span class="token punctuation">.</span>show_help<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 2. 查看游戏最高分</span>
Game<span class="token punctuation">.</span>show_top_score<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 创建游戏对象，开始游戏</span>
game <span class="token operator">=</span> Game<span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span>
game<span class="token punctuation">.</span>start_game<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 4. 游戏结束，查看游戏最高分</span>
Game<span class="token punctuation">.</span>show_top_score<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>小结</strong></p> <ul><li><strong>实例方法</strong> —— 方法内部需要访问 <strong>实例属性</strong> <ul><li><strong>实例方法</strong> 内部可以使用 <strong><code>类名.</code></strong> 访问 <strong>类属性</strong></li></ul></li> <li><strong>类方法</strong> —— 方法内部 <strong>只</strong> 需要访问 <strong>类属性</strong></li> <li><strong>静态方法</strong> —— 方法内部不需要访问 <strong>实例属性</strong> 和 <strong>类属性</strong></li></ul> <h2 id="单例"><a href="#单例" class="header-anchor">#</a> 单例</h2> <h3 id="单例设计模式"><a href="#单例设计模式" class="header-anchor">#</a> 单例设计模式</h3> <h4 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h4> <ul><li><strong>设计模式</strong> 是 <strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对 <strong>某一特定问题</strong> 的成熟的解决方案</li> <li>使用 <strong>设计模式</strong> 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li></ul> <h4 id="单例设计模式-2"><a href="#单例设计模式-2" class="header-anchor">#</a> 单例设计模式</h4> <ul><li>目的 —— 让 <strong>类</strong> 创建的对象，在系统中 只有 <strong>唯一的一个实例</strong></li> <li>每一次执行 <code>类名()</code> 返回的对象，<strong>内存地址是相同的</strong></li></ul> <h4 id="单例设计模式应用场景"><a href="#单例设计模式应用场景" class="header-anchor">#</a> 单例设计模式应用场景</h4> <ul><li>音乐播放对象</li> <li>回收站对象</li> <li>打印机对象</li> <li>……</li></ul> <h3 id="new-方法"><a href="#new-方法" class="header-anchor">#</a> __new__方法</h3> <ul><li>使用 <code>类名()</code> 创建对象时，<code>Python</code> 的解释器 首先会调用 <code>__new__</code> 方法为对象分配空间</li> <li><code>__new__</code> 是一个由 <code>object</code> 基类提供的<strong>内置的静态方法</strong>，主要作用有两个：
<ol><li>在内存中为对象 <strong>分配空间</strong></li> <li>返回 <strong>对象的引用</strong></li></ol></li> <li><code>Python</code> 的解释器获得对象的 <strong>引用</strong> 后，将引用作为 <strong>第一个参数</strong>，传递给 <code>__init__</code> 方法</li></ul> <h4 id="重写-new-方法-比较固定"><a href="#重写-new-方法-比较固定" class="header-anchor">#</a> 重写__new__方法（比较固定）</h4> <ul><li>重写 <code>__new__</code> 方法 一定要 <code>return super().__new__(cls)</code></li> <li>否则 <code>Python</code> 的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li> <li>注意：<code>__new__</code> 是一个静态方法，在调用时需要主动传递 <code>cls</code> 参数</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果不返回任何结果，</span>
        <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;初始化音乐播放对象&quot;</span><span class="token punctuation">)</span>

player <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>player<span class="token punctuation">)</span>
</code></pre></div><h3 id="python中的单例"><a href="#python中的单例" class="header-anchor">#</a> python中的单例</h3> <p><strong>单例</strong> —— 让 <strong>类</strong> 创建的对象，在系统中只有 <strong>唯一的一个实例</strong></p> <ol><li>定义一个 <strong>类属性</strong>，初始值是 <code>None</code>，用于记录单例对象的引用</li> <li>重写 <code>__new__</code> 方法</li> <li>如果 <strong>类属性</strong> <code>is None</code>，调用父类方法分配空间，并在类属性中记录结果</li> <li>返回 <strong>类属性</strong> 中记录的 <strong>对象引用</strong></li></ol> <div align="center"><img src="/school-note/assets/img/010_单例流程.d5d114b9.png" width="90%"></div> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 定义类属性记录单例对象引用</span>
    instance <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token comment"># 1. 判断类属性是否已经被赋值</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

        <span class="token comment"># 2. 返回类属性的单例引用</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance
</code></pre></div><h3 id="只执行一次初始化动作"><a href="#只执行一次初始化动作" class="header-anchor">#</a> 只执行一次初始化动作</h3> <ul><li>在每次使用 <code>类名()</code> 创建对象时，<code>Python</code> 的解释器都会自动调用两个方法：
<ul><li><code>__new__</code> 分配空间</li> <li><code>__init__</code> 对象初始化</li></ul></li> <li>在上一小节对 <code>__new__</code> 方法改造之后，每次都会得到 <strong>第一次被创建对象的引用</strong></li> <li>但是：<strong>初始化方法还会被再次调用</strong></li></ul> <h4 id="需求-2"><a href="#需求-2" class="header-anchor">#</a> 需求</h4> <ul><li>让 <strong>初始化动作</strong> 只被 <strong>执行一次</strong></li></ul> <h4 id="解决方法"><a href="#解决方法" class="header-anchor">#</a> 解决方法</h4> <ol><li>定义一个类属性 <code>init_flag</code> 标记<strong>是否执行过初始化动作</strong>，初始值为 <code>False</code></li> <li>在 <code>__init__</code> 方法中，判断 <code>init_flag</code>，如果为 <code>False</code> 就执行初始化动作</li> <li>然后将 <code>init_flag</code> 设置为 <code>True</code></li> <li>这样，再次自动调用 <code>__init__</code> 方法时，初始化动作就不会被再次执行了</li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 记录第一个被创建对象的引用</span>
    instance <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token comment"># 记录是否执行过初始化动作</span>
    init_flag <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token comment"># 1. 判断类属性是否是空对象</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 2. 调用父类的方法，为第一个对象分配空间</span>
            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

        <span class="token comment"># 3. 返回类属性保存的对象引用</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token keyword">if</span> <span class="token keyword">not</span> MusicPlayer<span class="token punctuation">.</span>init_flag<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;初始化音乐播放器&quot;</span><span class="token punctuation">)</span>

            MusicPlayer<span class="token punctuation">.</span>init_flag <span class="token operator">=</span> <span class="token boolean">True</span>

<span class="token comment"># 创建多个对象</span>
player1 <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>player1<span class="token punctuation">)</span>

player2 <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>player2<span class="token punctuation">)</span>
</code></pre></div><h2 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h2> <h3 id="异常的概念"><a href="#异常的概念" class="header-anchor">#</a> 异常的概念</h3> <ul><li>程序在运行时，如果 <code>Python</code> 解释器<strong>遇到</strong>到一个错误，会<strong>停止程序的执行，并且提示一些错误信息</strong>，这就是 <strong>异常</strong></li> <li><strong>程序停止执行并且提示错误信息</strong> 这个动作，我们通常称之为：<strong>抛出(raise)异常</strong></li> <li>程序开发时，很难将 <strong>所有的特殊情况</strong> 都处理的面面俱到，通过 <strong>异常捕获</strong> 可以针对突发事件做集中的处理，从而保证程序的稳定性和健壮性</li></ul> <h3 id="捕获异常"><a href="#捕获异常" class="header-anchor">#</a> 捕获异常</h3> <h4 id="简单的捕获异常语法"><a href="#简单的捕获异常语法" class="header-anchor">#</a> 简单的捕获异常语法</h4> <ul><li>在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加 <code>try(尝试)</code> 来 <strong>捕获异常</strong></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    尝试执行的代码
<span class="token keyword">except</span><span class="token punctuation">:</span>
    出现错误的处理
</code></pre></div><ul><li><code>try</code> <strong>尝试</strong>，下方编写要尝试代码，不确定是否能够正常执行的代码</li> <li><code>except</code> <strong>如果不是</strong>，下方编写尝试失败的代码</li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># 提示用户输入一个数字</span>
    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&quot;请输入数字：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;请输入正确的数字&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="错误类型捕获"><a href="#错误类型捕获" class="header-anchor">#</a> 错误类型捕获</h4> <ul><li>在程序执行时，可能会遇到 <strong>不同类型的异常</strong>，并且需要 <strong>针对不同类型的异常，做出不同的响应</strong>，这个时候，就需要捕获错误类型了</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># 尝试执行的代码</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> 错误类型<span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token comment"># 针对错误类型1，对应的代码处理</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> <span class="token punctuation">(</span>错误类型<span class="token number">2</span><span class="token punctuation">,</span> 错误类型<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 针对错误类型2 和 3，对应的代码处理</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;未知错误 %s&quot;</span> <span class="token operator">%</span> result<span class="token punctuation">)</span>
</code></pre></div><ul><li>当 <code>Python</code> 解释器 <strong>抛出异常</strong> 时，<strong>最后一行错误信息的第一个单词，就是错误类型</strong></li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&quot;请输入整数：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">/</span> num
    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;请输入正确的整数&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;除 0 错误&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>捕获未知错误</strong></p> <ul><li>在开发时，要预判到所有可能出现的错误，还是有一定难度的</li> <li>如果希望程序 <strong>无论出现任何错误</strong>，都不会因为 <code>Python</code> 解释器 <strong>抛出异常而被终止</strong>，可以再增加一个 <code>except</code></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;未知错误 %s&quot;</span> <span class="token operator">%</span> result<span class="token punctuation">)</span>
</code></pre></div><h4 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="header-anchor">#</a> 异常捕获完整语法</h4> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># 尝试执行的代码</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> 错误类型<span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token comment"># 针对错误类型1，对应的代码处理</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> 错误类型<span class="token number">2</span><span class="token punctuation">:</span>
    <span class="token comment"># 针对错误类型2，对应的代码处理</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> <span class="token punctuation">(</span>错误类型<span class="token number">3</span><span class="token punctuation">,</span> 错误类型<span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 针对错误类型3 和 4，对应的代码处理</span>
    <span class="token keyword">pass</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token comment"># 打印错误信息</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token comment"># 没有异常才会执行的代码</span>
    <span class="token keyword">pass</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token comment"># 无论是否有异常，都会执行的代码</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;无论是否有异常，都会执行的代码&quot;</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><code>else</code> 只有在没有异常时才会执行的代码</li> <li><code>finally</code> 无论是否有异常，都会执行的代码</li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&quot;请输入整数：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">/</span> num
    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;请输入正确的整数&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;除 0 错误&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;未知错误 %s&quot;</span> <span class="token operator">%</span> result<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;正常执行&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;执行完成，但是不保证正确&quot;</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="异常的传递"><a href="#异常的传递" class="header-anchor">#</a> 异常的传递</h3> <ul><li><strong>异常的传递</strong> —— 当函数/方法执行出现异常，会将异常传递给函数或方法的调用一方</li> <li>如果传递到主程序，仍然没有异常处理，程序才会被终止</li></ul> <p><strong>提示</strong></p> <ul><li>在开发中，可以在主函数中增加 <strong>异常捕获</strong></li> <li>而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 <strong>异常捕获</strong> 中</li> <li>这样就不需要在代码中，增加大量的 <strong>异常捕获</strong>，能够保证代码的整洁</li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&quot;请输入一个整数：&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;请输入正确的整数&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;未知错误 %s&quot;</span> <span class="token operator">%</span> result<span class="token punctuation">)</span>
</code></pre></div><h3 id="抛出-raise-异常"><a href="#抛出-raise-异常" class="header-anchor">#</a> 抛出 raise 异常</h3> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <ul><li>在开发中，除了 <strong>代码执行出错</strong> <code>Python</code> 解释器会 <strong>抛出</strong> 异常之外</li> <li>还可以根据 <strong>应用程序</strong> <strong>特有的业务需求</strong> <strong>主动抛出异常</strong></li></ul> <p><strong>示例</strong></p> <ul><li>提示用户 <strong>输入密码</strong>，如果 <strong>长度少于8</strong>，抛出<strong>异常</strong></li></ul> <div align="center"><img src="/school-note/assets/img/011_自定义异常.ecbea19b.png" width="90%"></div> <p><strong>注意</strong></p> <ul><li>当前函数只负责提示用户输入密码，如果 <strong>密码长度不正确，需要其他的函数进行额外处理</strong></li> <li>因此可以 <strong>抛出异常</strong>，由其他需要处理的函数 <strong>捕获异常</strong></li></ul> <h4 id="抛出异常"><a href="#抛出异常" class="header-anchor">#</a> 抛出异常</h4> <ul><li><code>Python</code> 中提供了一个 <code>Exception</code> <strong>异常类</strong></li> <li>在开发时，如果满足 <strong>特定业务需求时，希望抛出异常</strong>，可以：
<ul><li>创建 一个 <code>Exception</code> 的 <strong>对象</strong></li> <li>使用 <code>raise</code> 关键字 抛出 <strong>异常对象</strong></li></ul></li></ul> <p><strong>需求</strong></p> <ul><li>定义 <code>input_password</code> 函数，提示用户输入密码</li> <li>如果用户输入长度 &lt; 8，抛出异常</li> <li>如果用户输入长度 &gt;=8，返回输入的密码</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">input_password</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 1. 提示用户输入密码</span>
    pwd <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">&quot;请输入密码：&quot;</span><span class="token punctuation">)</span>

    <span class="token comment"># 2. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">8</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> pwd

    <span class="token comment"># 3. 密码长度不够，需要抛出异常</span>
    <span class="token comment"># 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数</span>
    ex <span class="token operator">=</span> Exception<span class="token punctuation">(</span><span class="token string">&quot;密码长度不够&quot;</span><span class="token punctuation">)</span>

    <span class="token comment"># 2&gt; 抛出异常对象</span>
    <span class="token keyword">raise</span> ex

<span class="token keyword">try</span><span class="token punctuation">:</span>
    user_pwd <span class="token operator">=</span> input_password<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>user_pwd<span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> result<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;发现错误：%s&quot;</span> <span class="token operator">%</span> result<span class="token punctuation">)</span>
</code></pre></div><h2 id="模块和包"><a href="#模块和包" class="header-anchor">#</a> 模块和包</h2> <h3 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h3> <h4 id="模块的概念"><a href="#模块的概念" class="header-anchor">#</a> 模块的概念</h4> <ul><li><strong>模块</strong>是 <code>Python</code> 程序架构的一个<strong>核心概念</strong></li> <li>每一个以扩展名 <code>py</code> 结尾的 <code>Python</code> 源代码文件都是一个 <strong>模块</strong></li> <li><strong>模块名</strong> 同样也是一个 <strong>标识符</strong>，需要符合标识符的命名规则</li> <li>在模块中定义的 <strong>全局变量、函数、类</strong> 都是提供给外界直接使用的 <strong>工具</strong></li> <li><strong>模块</strong> 就好比是 <strong>工具包</strong>，要想使用这个工具包中的工具，就需要先 <strong>导入</strong> 这个模块</li></ul> <h4 id="模块导入的两种方式"><a href="#模块导入的两种方式" class="header-anchor">#</a> 模块导入的两种方式</h4> <ol><li>import导入</li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> 模块名<span class="token number">1</span><span class="token punctuation">,</span> 模块名<span class="token number">2</span> 

<span class="token comment"># 提示：在导入模块时，每个导入应该独占一行</span>
<span class="token keyword">import</span> 模块名<span class="token number">1</span>
<span class="token keyword">import</span> 模块名<span class="token number">2</span>
</code></pre></div><p>导入之后通过 <code>模块名.</code> 使用模块提供的工具 —— 全局变量、函数、类</p> <p><strong>使用 as 指定模块的别名</strong></p> <ul><li>如果模块的名字太长，可以使用 <code>as</code> 指定模块的名称，以方便在代码中的使用</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> 模块名<span class="token number">1</span> <span class="token keyword">as</span> 模块别名
</code></pre></div><ol start="2"><li>from...import 导入</li></ol> <ul><li>如果希望 <strong>从某一个模块</strong> 中，导入 <strong>部分</strong> 工具，就可以使用 <code>from ... import</code> 的方式</li> <li><code>import 模块名</code> 是 <strong>一次性</strong> 把模块中 <strong>所有工具全部导入</strong>，并且通过 <strong>模块名/别名</strong> 访问</li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 从 模块 导入 某一个工具</span>
<span class="token keyword">from</span> 模块名<span class="token number">1</span> <span class="token keyword">import</span> 工具名
</code></pre></div><p>导入之后，<strong>不需要</strong>通过 <code>模块名.</code> 使用，可以直接使用<strong>模块提供的工具 —— 全局变量、函数、类</strong></p> <p><strong>注意</strong> ：如果 <strong>两个模块</strong>，存在 <strong>同名的函数</strong>，那么 <strong>后导入模块的函数</strong>，会 <strong>覆盖掉先导入的函数</strong></p> <ul><li>开发时 <code>import</code> 代码应该统一写在 <strong>代码的顶部</strong>，更容易及时发现冲突</li> <li>一旦发现冲突，可以使用 <code>as</code> 关键字 <strong>给其中一个工具起一个别名</strong></li></ul> <h4 id="模块的搜索顺序"><a href="#模块的搜索顺序" class="header-anchor">#</a> 模块的搜索顺序</h4> <p><code>Python</code> 的解释器在 <strong>导入模块</strong> 时，会：</p> <ul><li>搜索 <strong>当前目录</strong> 指定模块名的文件，如果有就直接导入</li> <li>如果没有，再搜索 <strong>系统目录</strong></li> <li><code>Python</code> 中每一个模块都有一个内置属性 <code>__file__</code> 可以查看模块的完整路径</li></ul> <p><strong>示例</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> random
<span class="token comment"># 生成一个 0～10 的数字</span>
rand <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>rand<span class="token punctuation">)</span>
</code></pre></div><p><strong>注意</strong>：如果当前目录下，存在一个 <code>random.py</code> 的文件，程序就无法正常执行了！这个时候，<code>Python</code> 的解释器会加载当前目录下的 <code>random.py</code> 而不会加载系统的 <code>random</code> 模块。</p> <h4 id="原则-每一个文件都应该是可以被导入的"><a href="#原则-每一个文件都应该是可以被导入的" class="header-anchor">#</a> 原则——每一个文件都应该是可以被导入的</h4> <ul><li>一个 独立的 <code>Python</code> 文件就是一个 <strong>模块</strong></li> <li>在导入文件时，文件中 <strong>所有没有任何缩进的代码</strong> 都会被执行一遍！</li></ul> <p><strong>实际场景</strong></p> <ul><li>在实际开发中，每一个模块都是独立开发的，大多都有专人负责</li> <li>开发人员通常会在模块下方增加一些测试代码，<strong>仅在模块内使用，而被导入到其他文件中不需要执行</strong></li></ul> <p><strong>__name__属性</strong></p> <ul><li><code>__name__</code> 是 <code>Python</code> 的一个内置属性，记录着一个字符串</li> <li>如果是被其他文件导入的，<code>__name__</code> 就是 <code>模块名</code></li> <li>如果是当前执行的程序 <code>__name__</code> 是 <code>__main__</code></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 导入模块</span>
<span class="token comment"># 定义全局变量</span>
<span class="token comment"># 定义类</span>
<span class="token comment"># 定义函数</span>

<span class="token comment"># 在代码的最下方</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># ...</span>
    <span class="token keyword">pass</span>

<span class="token comment"># 根据 __name__ 判断是否执行下方代码</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="包-package"><a href="#包-package" class="header-anchor">#</a> 包（Package）</h3> <h4 id="概念-3"><a href="#概念-3" class="header-anchor">#</a> 概念</h4> <ul><li><strong>包</strong> 是一个 <strong>包含多个模块</strong> 的 <strong>特殊目录</strong></li> <li>目录下有一个 <strong>特殊的文件</strong> <code>__init__.py</code></li> <li>包名的命名方式和变量名一致，<code>小写字母 + _</code></li> <li>使用 <code>import 包名</code> 可以一次性导入包中所有的模块</li> <li>要在外界使用 包中的模块，需要在 <code>__init__.py</code> 中指定 <strong>对外界提供的模块列表</strong></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 从 当前目录 导入 模块列表</span>
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> send_message
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> receive_message
</code></pre></div><h3 id="发布模块"><a href="#发布模块" class="header-anchor">#</a> 发布模块</h3> <ul><li>如果希望自己开发的模块，分享给其他人，可以按照以下步骤操作</li></ul> <h4 id="制作发布压缩包步骤"><a href="#制作发布压缩包步骤" class="header-anchor">#</a> 制作发布压缩包步骤</h4> <ol><li>创建 <code>setup.py</code></li></ol> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">from</span> distutils<span class="token punctuation">.</span>core <span class="token keyword">import</span> setup

setup<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">&quot;hm_message&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 包名</span>
      version<span class="token operator">=</span><span class="token string">&quot;1.0&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 版本</span>
      description<span class="token operator">=</span><span class="token string">&quot;itheima's 发送和接收消息模块&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 描述信息</span>
      long_description<span class="token operator">=</span><span class="token string">&quot;完整的发送和接收消息模块&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 完整描述信息</span>
      author<span class="token operator">=</span><span class="token string">&quot;itheima&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 作者</span>
      author_email<span class="token operator">=</span><span class="token string">&quot;itheima@itheima.com&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 作者邮箱</span>
      url<span class="token operator">=</span><span class="token string">&quot;www.itheima.com&quot;</span><span class="token punctuation">,</span>  <span class="token comment"># 主页</span>
      py_modules<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&quot;hm_message.send_message&quot;</span><span class="token punctuation">,</span>
                  <span class="token string">&quot;hm_message.receive_message&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>有关字典参数的详细信息，可以参阅官方网站：<a href="https://docs.python.org/2/distutils/apiref.html" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol start="2"><li>构建模块</li></ol> <div class="language-python extra-class"><pre class="language-python"><code>$   python3 setup<span class="token punctuation">.</span>py build
</code></pre></div><ol start="3"><li>生成发布压缩包</li></ol> <div class="language-python extra-class"><pre class="language-python"><code>$ python3 setup<span class="token punctuation">.</span>py sdist
</code></pre></div><p>注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！</p> <h4 id="安装模块"><a href="#安装模块" class="header-anchor">#</a> 安装模块</h4> <div class="language-python extra-class"><pre class="language-python"><code>$ tar <span class="token operator">-</span>zxvf hm_message<span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz 
$ sudo python3 setup<span class="token punctuation">.</span>py install
</code></pre></div><p><strong>卸载模块</strong>：直接从安装目录下，把安装模块的目录删除就可以</p> <h2 id="文件"><a href="#文件" class="header-anchor">#</a> 文件</h2> <h3 id="文件的存储方式"><a href="#文件的存储方式" class="header-anchor">#</a> 文件的存储方式</h3> <ul><li>在计算机中，文件是以 二进制 的方式保存在磁盘上的</li></ul> <p><strong>文本文件和二进制文件</strong></p> <ul><li><p>文本文件</p> <ul><li>可以使用文本编辑软件查看</li> <li>本质上还是二进制文件</li> <li>例如：python 的源程序</li></ul></li> <li><p>二进制文件</p> <ul><li>保存的内容不是给人直接阅读的，而是提供给其他软件使用的</li> <li>例如：图片文件、音频文件、视频文件等等</li> <li>二进制文件不能使用文本编辑软件 查看</li></ul></li></ul> <h3 id="文件的基本操作"><a href="#文件的基本操作" class="header-anchor">#</a> 文件的基本操作</h3> <h4 id="操作文件的套路"><a href="#操作文件的套路" class="header-anchor">#</a> 操作文件的套路</h4> <p>在计算机中要操作文件的套路非常固定，一共包含三个步骤：</p> <ol><li>打开文件</li> <li>读、写文件
<ul><li><strong>读</strong> 将文件内容读入内存</li> <li><strong>写</strong> 将内存内容写入文件</li></ul></li> <li>关闭文件</li></ol> <h4 id="操作文件的函数-方法"><a href="#操作文件的函数-方法" class="header-anchor">#</a> 操作文件的函数/方法</h4> <p>在 <code>Python</code> 中要操作文件需要记住 1 个函数和 3 个方法</p> <table><thead><tr><th>序号</th> <th>函数/方法</th> <th>说明</th></tr></thead> <tbody><tr><td>01</td> <td>open</td> <td>打开文件，并且返回文件操作对象</td></tr> <tr><td>02</td> <td>read</td> <td>将文件内容读取到内存</td></tr> <tr><td>03</td> <td>write</td> <td>将指定内容写入文件</td></tr> <tr><td>04</td> <td>close</td> <td>关闭文件</td></tr></tbody></table> <ul><li><code>open</code> 函数负责打开文件，并且返回文件对象</li> <li><code>read/write/close</code> 三个方法都需要通过文件对象来调用</li></ul> <h4 id="read-方法-读取文件"><a href="#read-方法-读取文件" class="header-anchor">#</a> read 方法 —— 读取文件</h4> <ul><li><code>open</code> 函数的第一个参数是要打开的文件名（文件名区分大小写）
<ul><li>如果文件存在，返回文件操作对象</li> <li>如果文件不存在，会抛出异常</li></ul></li> <li><code>read</code> 方法可以一次性读入并返回文件的所有内容</li> <li><code>close</code> 方法负责关闭文件
<ul><li>如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问</li></ul></li></ul> <p>注意：<code>read</code>方法执行后，会把文件指针移动到文件的末尾</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 1. 打开 - 文件名需要注意大小写</span>
<span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&quot;README&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 2. 读取</span>
text <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>

<span class="token comment"># 3. 关闭</span>
<span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>文件指针</strong></p> <ul><li>文件指针标记从哪个位置开始读取数据</li> <li>第一次打开文件时，通常文件指针会指向文件的开始位置</li> <li>当执行了 <code>read</code> 方法后，文件指针会移动到读取内容的末尾
<ul><li>默认情况下会移动到文件末尾</li></ul></li></ul> <p><strong>注意</strong>：如果执行了一次 <code>read</code> 方法，读取了所有内容，那么再次调用 <code>read</code> 方法，不会读取内容。因为第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容。</p> <h4 id="打开文件的方式"><a href="#打开文件的方式" class="header-anchor">#</a> 打开文件的方式</h4> <p><code>open</code> 函数默认以 <strong>只读方式</strong> 打开文件，并且返回文件对象<br>
语法如下：</p> <div class="language-python extra-class"><pre class="language-python"><code>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&quot;文件名&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;访问方式&quot;</span><span class="token punctuation">)</span>
</code></pre></div><table><thead><tr><th style="text-align:center;">访问方式</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:center;">r</td> <td>以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常</td></tr> <tr><td style="text-align:center;">w</td> <td>以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr> <tr><td style="text-align:center;">a</td> <td>以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr> <tr><td style="text-align:center;">r+</td> <td>以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常</td></tr> <tr><td style="text-align:center;">w+</td> <td>以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr> <tr><td style="text-align:center;">a+</td> <td>以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr></tbody></table> <p><strong>提示</strong></p> <ul><li>频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 <strong>只读、只写</strong> 的方式来操作文件</li></ul> <p><strong>写入文件示例：</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 打开文件</span>
f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&quot;README&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;w&quot;</span><span class="token punctuation">)</span>

f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">&quot;hello python！\n&quot;</span><span class="token punctuation">)</span>
f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">&quot;今天天气真好&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 关闭文件</span>
f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="按行读取文件内容"><a href="#按行读取文件内容" class="header-anchor">#</a> 按行读取文件内容</h4> <ul><li><code>read</code> 方法默认会把文件的 <strong>所有内容一次性读取到内存</strong></li> <li>如果文件太大，对内存的占用会非常严重</li></ul> <p><strong><code>readline</code> 方法</strong></p> <ul><li><code>readline</code> 方法可以一次读取一行内容</li> <li>方法执行后，会把文件指针移动到下一行，准备再次读取</li></ul> <p><strong>读取大文件的正确姿势</strong></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 打开文件</span>
<span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&quot;README&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token comment"># 读取一行内容</span>
    text <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 判断是否读到内容</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> text<span class="token punctuation">:</span>
        <span class="token keyword">break</span>

    <span class="token comment"># 每读取一行的末尾已经有了一个 `\n`</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 关闭文件</span>
<span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="文件-目录的常用管理操作"><a href="#文件-目录的常用管理操作" class="header-anchor">#</a> 文件/目录的常用管理操作</h3> <ul><li>在终端/文件浏览器中可以执行常规的文件/目录管理操作，例如：
<ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li> <li>在 <code>Python</code> 中，如果希望通过程序实现上述功能，需要导入 <code>os</code> 模块</li></ul> <h4 id="文件操作"><a href="#文件操作" class="header-anchor">#</a> 文件操作</h4> <table><thead><tr><th>序号</th> <th>方法名</th> <th>说明</th> <th>示例</th></tr></thead> <tbody><tr><td>01</td> <td>rename</td> <td>重命名文件</td> <td>os.rename(源文件名, 目标文件名)</td></tr> <tr><td>02</td> <td>remove</td> <td>删除文件</td> <td>os.remove(文件名)</td></tr></tbody></table> <h4 id="目录操作"><a href="#目录操作" class="header-anchor">#</a> 目录操作</h4> <table><thead><tr><th>序号</th> <th>方法名</th> <th>说明</th> <th>示例</th></tr></thead> <tbody><tr><td>01</td> <td>listdir</td> <td>目录列表</td> <td>os.listdir(目录名)</td></tr> <tr><td>02</td> <td>mkdir</td> <td>创建目录</td> <td>os.mkdir(目录名)</td></tr> <tr><td>03</td> <td>rmdir</td> <td>删除目录</td> <td>os.rmdir(目录名)</td></tr> <tr><td>04</td> <td>getcwd</td> <td>获取当前目录</td> <td>os.getcwd()</td></tr> <tr><td>05</td> <td>chdir</td> <td>修改工作目录</td> <td>os.chdir(目标目录)</td></tr> <tr><td>06</td> <td>path.isdir</td> <td>判断是否是文件</td> <td>os.path.isdir(文件路径)</td></tr></tbody></table> <p><strong>提示</strong></p> <ul><li>文件或者目录操作都支持相对路径和绝对路径</li></ul> <h2 id="eval-函数"><a href="#eval-函数" class="header-anchor">#</a> eval 函数</h2> <p><code>eval()</code> 函数十分强大 —— 将字符串当成有效的表达式来求值并返回计算结果</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 基本的数学计算</span>
In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;1 + 1&quot;</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">2</span>

<span class="token comment"># 字符串重复</span>
In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;'*' * 10&quot;</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'**********'</span>

<span class="token comment"># 将字符串转换成列表</span>
In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;[1, 2, 3, 4, 5]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">list</span>

<span class="token comment"># 将字符串转换成字典</span>
In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;{'name': 'xiaoming', 'age': 18}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">dict</span>
</code></pre></div><p><strong>注意</strong></p> <ul><li>在开发时千万不要使用 <code>eval</code> 直接转换 <code>input</code> 的结果</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/school-note/python/python语法规则.html" class="prev">
        python语法规则
      </a></span> <span class="next"><a href="/school-note/无人机项目/PX4开发环境搭建.html">
        PX4开发环境搭建
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/school-note/assets/js/app.73bf7409.js" defer></script><script src="/school-note/assets/js/2.26c8f057.js" defer></script><script src="/school-note/assets/js/1.9edbc7d9.js" defer></script><script src="/school-note/assets/js/17.0008473c.js" defer></script>
  </body>
</html>
